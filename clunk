#!/usr/bin/perl

use strict;
use warnings;

use lib 'lib';

use 5.010001;
use Getopt::Long 2.38 ();
use App::Ack::ConfigLoader ();


Getopt::Long::Configure( 'bundling', 'no_ignore_case' );


say 'Before processing, @ARGV is:';
say for @ARGV;

my $options_used = options_used();
{use Data::Dumper; local $Data::Dumper::Sortkeys=1; warn Dumper( $options_used )}

say 'After processing, @ARGV is:';
say for @ARGV;

find_mutex_options( $options_used );

exit 0;


sub in {
    my $needle = shift;
    my $haystack = shift;

    for my $i ( @{$haystack} ) {
        return 1 if $i eq $needle;
    }

    return 0;
}

sub find_mutex_options {
    my $used = shift;

    my $invalids = App::Ack::ConfigLoader::_invalid_combinations();

    for my $used_arg ( sort keys %{$used} ) {
        my $conflicts = $invalids->{$used_arg};

        for my $potential_conflict ( @{$conflicts} ) {
            if ( $used->{$potential_conflict} ) {
                # XXX This should say what the user typed, not what the internal preferred abbreviation is.
                say "$used_arg and $potential_conflict are mutex";
            }
        }
    }
}


# Processes the command line option and returns a hash of the options that were
# used on the command line, using their full name.  "--prox" shows up in the hash as "--proximate".

sub options_used {
    local @ARGV = @ARGV;

    # We don't care about the hashes passed in to get_arg_spec().
    my $real_spec = App::Ack::ConfigLoader::get_arg_spec( {}, {} );

    # Go through the specs and change them to just set a value in a hash.
    # We don't want it to take action, only to note that the argument appeared.
    my $seen;
    my %hashifying_spec = (
        map {
            $_ => sub { ++$seen->{+shift} }
        } keys %{$real_spec}
    );

    # Process the arguments, which has no effect and reads through our local @ARGV copy.
    # The elements of $seen will be populated during this process.
    Getopt::Long::GetOptions( %hashifying_spec );

    return $seen;
}
